/*
  This class has been generated by the Code Generator
*/

package com.cordys.coe.tools.useradmin;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.regex.Pattern;

import com.cordys.coe.tools.useradmin.cordys.CordysInstallation;
import com.cordys.coe.tools.useradmin.cordys.CordysObject;
import com.cordys.coe.tools.useradmin.cordys.CordysObjectList;
import com.cordys.coe.tools.useradmin.cordys.CordysUser;
import com.cordys.coe.tools.useradmin.cordys.CordysVersion;
import com.cordys.coe.tools.useradmin.cordys.LDAP;
import com.cordys.coe.tools.useradmin.cordys.Role;
import com.cordys.coe.tools.useradmin.cordys.TeamAssignment;
import com.cordys.coe.tools.useradmin.cordys.Unit;
import com.cordys.coe.tools.useradmin.cordys.XMLStore;
import com.cordys.coe.tools.useradmin.cordys.XMLStoreCache.XSCacheKey;
import com.cordys.coe.tools.useradmin.exception.UserAdminException;
import com.cordys.coe.tools.useradmin.util.Base64Coder;
import com.cordys.coe.tools.useradmin.util.Util;
import com.cordys.coe.tools.useradmin.util.XMLObject;
import com.cordys.cpc.bsf.busobject.BSF;
import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.eibus.directory.soap.EntryToXML;
import com.eibus.directory.soap.XMLToEntry;
import com.eibus.util.cache.CacheKey;
import com.eibus.xml.nom.Document;
import com.eibus.xml.nom.Node;
import com.eibus.xml.xpath.XPath;
import com.novell.ldap.LDAPAttribute;
import com.novell.ldap.LDAPAttributeSet;
import com.novell.ldap.LDAPEntry;


/**
 * Class to support exporting/importing cordys organizational users, including role/task/team assignments.
 * The export has the xml as resulting from LDAP / XDS content.
 * 
 * @author kekema
 *
 */
public class ImportExport extends ImportExportBase
{
    public ImportExport()
    {
        this((BusObjectConfig)null);
    }

    public ImportExport(BusObjectConfig config)
    {
        super(config);
    }

    /**
     * Export Cordys org users and return in base64 as to enable download in ui client.
     * Base64 result is wrapped in Base64 xml tag.
     * 
     * @return
     */
    public static int exportCordysUsersBase64()
    {
    	Document xmlDoc = BSF.getXMLDocument();
    	int result = 0;
    	int cordysExport = 0;
    	try 
    	{
    		cordysExport = exportCordysUsers();
    		if (cordysExport > 0)
    		{
    			result = xmlDoc.parseString("<Base64>" + Base64Coder.encodeString(Node.writeToString(cordysExport, true))+"</Base64>");
    		}
    	}
		catch (Exception e)
		{
			throw new UserAdminException("Not able to compose base64 export cordys users", e);
		}
    	finally
    	{
    		if (cordysExport > 0)
    		{
    			Node.delete(cordysExport);
    			cordysExport = 0;
    		}
    	}
    	return result;
    }
    
    /**
     * Actual export or Cordys org users.
     * 
     * @return
     */
    private static int exportCordysUsers()
    {
		Document xmlDoc = BSF.getXMLDocument();
		ArrayList<CordysUser> cordysUsers = CordysUser.getOrgUsersList(null, false, false);
		int resultNode = 0;
		int exportNode = 0;
		int usersNode = 0;
		try
		{
			exportNode = xmlDoc.createElement("CordysExport");
			Node.createElement("ExportUser", exportNode);
			Node.createElement("ExportOrganization", exportNode);
			Node.createTextElement("ExportDate", Util.getCurrentDate(), exportNode);
			CordysVersion cordysVersion = CordysInstallation.getVersion();
			Node.createTextElement("CordysVersion", cordysVersion.getVersion(), exportNode);
			usersNode = Node.createElement("Users", exportNode);
			for (CordysUser cordysUser : cordysUsers)
			{
				try
				{
					// cordys user
					int userNode = Node.createElement("User", usersNode);
					Node.setAttribute(userNode, "dn", cordysUser.getOrgUserDN());
					String displayName = cordysUser.getDescription();
					String osIdentitiy = cordysUser.getOSIdentity();
					Node.setAttribute(userNode, "description", displayName + " (" + osIdentitiy + ")");
					// auth user data
					int authUserNode = Node.createElement("AuthUser", userNode);
					LDAPEntry authUserEntry = LDAP.getEntry(cordysUser.getAuthUserDN());
					EntryToXML.appendToChildren(authUserEntry, authUserNode);
					// org user data
					int orgUserNode = Node.createElement("OrgUser", userNode);
					LDAPEntry orgUserEntry = LDAP.getEntry(cordysUser.getOrgUserDN());
					EntryToXML.appendToChildren(orgUserEntry, orgUserNode);
					// task assignments
					int tasksNode = Node.createElement("TaskAssignments", userNode);
					CordysObjectList taskAssignments = null;
					try
					{
						taskAssignments = com.cordys.coe.tools.useradmin.cordys.Task.getAssignedTasks(cordysUser.getOrgUserDN());
						for (CordysObject cordysObject : taskAssignments.getList())
						{
							com.cordys.coe.tools.useradmin.cordys.Task task = (com.cordys.coe.tools.useradmin.cordys.Task)cordysObject;
							Node.appendToChildren(task.getNOMCopy(), tasksNode);
						}
					}
					finally
					{
						if (taskAssignments != null)
						{
							taskAssignments.cleanup();
						}
					}
					// team assignments
					int teamsNode = Node.createElement("TeamAssignments", userNode);
					CordysObjectList teamAssignments = null;
					try
					{
						teamAssignments = TeamAssignment.getAssignments(cordysUser.getOrgUserDN(), "", false);
						for (CordysObject cordysObject : teamAssignments.getList())
						{
							TeamAssignment teamAssignment = (TeamAssignment)cordysObject;
							Node.appendToChildren(teamAssignment.getNOMCopy(), teamsNode);
						}
					}
					finally
					{
						if (teamAssignments != null)
						{
							teamAssignments.cleanup();
						}
					}
				}
		        catch (Exception e)
		        {
		        	throw new UserAdminException("Not able to export cordys user " + cordysUser.getOrgUserDN(), e);
		        }
			}
			// make organization / ldap root variable
			String organization = BSF.getOrganization();
			String cordysExport = Node.writeToString(exportNode, true);
			cordysExport = cordysExport.replace(organization, "$organization");
			String searchRoot = LDAP.getRoot();
			cordysExport = cordysExport.replace(searchRoot, "$ldap.root");
			resultNode = xmlDoc.parseString(cordysExport);
			// set export user/org
			Node.setDataElement(resultNode, "ExportUser", BSF.getUser());
			Node.setDataElement(resultNode, "ExportOrganization", organization);
		}
		catch (Exception e)
		{
			throw new UserAdminException("Not able to export cordys users", e);
		}
		finally
		{
			if (exportNode > 0)
			{
				Node.delete(exportNode);
			}
		}
		return resultNode;
    }

    public void onInsert()
    {
    	// N.A.
    }

    public void onUpdate()
    {
    	// N.A.
    }

    public void onDelete()
    {
    	// N.A.
    }

    /**
     * Import the given user from export file into a Cordys org user including roles/task/team assignments.
     * The file is expected in XMLStore as per the key.
     * 
     * @param xmlStoreKey
     * @param orgUserDN
     */
    public static void importCordysUser(String xmlStoreKey, String orgUserDN)
    {
		XMLObject cordysExport = null;
		int userSubstNode = 0;
		try
		{
			cordysExport = XMLStore.getXMLObjectByCache(xmlStoreKey);
			if (cordysExport.getNOMNode() == 0)
			{
				// cache timeout situation - recall as to reload from XMLStore
				cordysExport = XMLStore.getXMLObjectByCache(xmlStoreKey);
			}
			if (cordysExport != null)
			{
				int cordysExportNode = cordysExport.getNOMNode();
				String version = Node.getDataElement(cordysExportNode, "CordysVersion", "");
				CordysVersion exportCordysVersion = new CordysVersion(version);
				CordysVersion importCordysVersion = CordysInstallation.getVersion();
				if (exportCordysVersion.getMajorMinor().equals(importCordysVersion.getMajorMinor()))
				{				
					// find the user in the export
					String dn = orgUserDN.replace(BSF.getOrganization(), "$organization");
					int userNode = XPath.getFirstMatch(".//Users/User[@dn=\""+dn+"\"]", null, cordysExportNode);
					if (userNode > 0)
					{
						// substitute variables on org/ldap root
						HashMap<String, String> properties = new HashMap<String, String>();
						properties.put("organization", BSF.getOrganization());
						properties.put("ldap.root", LDAP.getRoot());
						userSubstNode = substituteVariables(userNode, properties);		
						// actual import
				        doImportCordysUser(userSubstNode);
					}
					else
					{
						throw new UserAdminException("Import Cordys user: user not found in export (" + orgUserDN + ")");
					}
				}
				else
				{
					throw new UserAdminException("Import Cordys users: users were exported under a different Cordys version ("+exportCordysVersion.getMajorMinor()+").");
				}					
			}
			else
			{
				throw new Exception("Import Cordys user: export not found in XMLStore (" + xmlStoreKey + ")");
			}
		}
		catch (UserAdminException uae)
		{
			throw uae;
		}
		catch (Exception e)
		{
			throw new UserAdminException("Not able to import cordys user " + orgUserDN, e);
		}
		finally
		{
			// userSubstNode is result from substitution, so cleanup
			if (userSubstNode > 0)
			{
				Node.delete(userSubstNode);
				userSubstNode = 0;
			}
			// no cleanup of cordysExport - will be freed automatically upon time phase cache timeout
		}
    }
    
    /**
     * Import all users from the given file.
     * 
     * @param xmlStoreKey
     */
	public static void importCordysUsers(String xmlStoreKey)
	{
		XMLObject cordysExport = null;
		int cordysExportSubstNode = 0;
		try
		{
			cordysExport = XMLStore.getXMLObject(xmlStoreKey);
			if (cordysExport != null)
			{
				int cordysExportNode = cordysExport.getNOMNode();
				String version = Node.getDataElement(cordysExportNode, "CordysVersion", "");
				CordysVersion exportCordysVersion = new CordysVersion(version);
				CordysVersion importCordysVersion = CordysInstallation.getVersion();
				if (exportCordysVersion.getMajorMinor().equals(importCordysVersion.getMajorMinor()))
				{
					// substitute variables on org/ldap root
					HashMap<String, String> properties = new HashMap<String, String>();
					properties.put("organization", BSF.getOrganization());
					properties.put("ldap.root", LDAP.getRoot());
					cordysExportSubstNode = substituteVariables(cordysExportNode, properties);
					// find all users
					int[] userNodes = XPath.getMatchingNodes(".//Users/User", null, cordysExportSubstNode);
			        for (int userNode : userNodes) 
			        {
			        	doImportCordysUser(userNode);
			        }
				}
				else
				{
					throw new UserAdminException("Import Cordys users: users were exported under a different Cordys version("+exportCordysVersion.getMajorMinor()+").");
				}
			}
			else
			{
				throw new UserAdminException("Import Cordys users: export not found in XMLStore (" + xmlStoreKey + ")");
			}
		}
		catch (Exception e)
		{
			throw new UserAdminException("Not able to import cordys users", e);
		}
		finally
		{
			if (cordysExportSubstNode > 0)
			{
				Node.delete(cordysExportSubstNode);
				cordysExportSubstNode = 0;
			}
			if (cordysExport != null)
			{
				cordysExport.freeXMLMemory();
			}
		}		
	}
	
	private static void doImportCordysUser(int userNode)
	{
		int authUserEntryNode = XPath.getFirstMatch("AuthUser/entry", null, userNode);
		if (authUserEntryNode > 0)
		{
			String authUserDN = Node.getAttribute(authUserEntryNode, "dn");
	        if (!LDAP.entryExists(authUserDN))
	        {
	        	importAuthUser(authUserEntryNode);
	        }
		}
		int orgUserEntryNode = XPath.getFirstMatch("OrgUser/entry", null, userNode);
		if (orgUserEntryNode > 0)
		{
			String orgUserDN = Node.getAttribute(orgUserEntryNode, "dn");
	        if (!LDAP.entryExists(orgUserDN))
	        {
	        	// import org user
	        	importOrgUser(orgUserEntryNode);        	
	        	// import task assignments
				int taskAssignmentsNode = XPath.getFirstMatch("TaskAssignments", null, userNode);
				importTaskAssignments(orgUserDN, taskAssignmentsNode);
	        	// import team assignments
				int teamAssignmentsNode = XPath.getFirstMatch("TeamAssignments", null, userNode);
				importTeamAssignments(orgUserDN, teamAssignmentsNode);				
	        }
		}
	}
	
	private static void importAuthUser(int authUserEntryNode)
	{
		// set default organization to current
		int defaultContextNode = XPath.getFirstMatch("defaultcontext", null, authUserEntryNode);
		Node.setDataElement(defaultContextNode, "string", BSF.getOrganization());
		LDAPEntry le = XMLToEntry.getEntry(authUserEntryNode);
		LDAP.insertEntry(le);
	}
	
	private static void importOrgUser(int orgUserEntryNode)
	{
		LDAPEntry le = XMLToEntry.getEntry(orgUserEntryNode);
    	LDAPAttributeSet attrs = le.getAttributeSet();
    	LDAPAttribute role = attrs.getAttribute("role");
    	if (role != null)
    	{
    		// only include existing roles
    		ArrayList<String> exportRoles = new ArrayList<String>(Arrays.asList(role.getStringValueArray()));
    		ArrayList<String> importRoles = new ArrayList<String>();
    		String defaultRole = "cn=everyoneIn" + Util.getCurrentOrgName() + ",cn=organizational roles," + BSF.getOrganization();
    		importRoles.add(defaultRole);
            for (String roleDN : exportRoles)
            {
            	if (LDAP.entryExists(roleDN))
            	{
            		importRoles.add(roleDN);
            	}
            }
        	attrs.remove(role);
        	role = new LDAPAttribute("role");
            for (String roleDN : importRoles)
            {
            	role.addValue(roleDN);
            }
            attrs.add(role);
    	}
		LDAP.insertEntry(le);
	}
	
	private static void importTaskAssignments(String orgUserDN, int taskAssignmentsNode)
	{
		ArrayList<String> assignedTaskIDs = new ArrayList<String>();
		int[] taskNodes = XPath.getMatchingNodes("Task", null, taskAssignmentsNode);
        for (int taskNode : taskNodes) 
        {
        	String taskID = Node.getAttribute(taskNode, "id");
        	if (Util.isSet(taskID))
        	{
        		assignedTaskIDs.add(taskID);
        	}
        }
        if (assignedTaskIDs.size() > 0)
        {
        	com.cordys.coe.tools.useradmin.cordys.Task.updateAssignedTasks(orgUserDN, assignedTaskIDs);
        }
	}
	
	private static void importTeamAssignments(String orgUserDN, int teamAssignmentsNode)
	{
		// no reuse of existing teams code as assignments from export file might contain date-effective assignments
		// if somehow already assignments exist, don't import any
		boolean assignmentsExist = TeamAssignment.assignmentsExist(orgUserDN, false);
		if (!assignmentsExist)
		{
			// wrap assignments from export into TeamAssignment objects
			ArrayList<TeamAssignment> exportAssignments = new ArrayList<TeamAssignment>();
			int[] assignmentNodes = XPath.getMatchingNodes("Assignment", null, teamAssignmentsNode);
			TeamAssignment principleAssignment = null;
	        for (int assignmentNode : assignmentNodes) 
	        {
	        	TeamAssignment teamAssignment = new TeamAssignment(assignmentNode);
	        	exportAssignments.add(teamAssignment);
	        	if (teamAssignment.getIsPrincipalUnit())
	        	{
	        		principleAssignment = teamAssignment;
	        	}
	        }
	        if (exportAssignments.size() > 0)
	        {
	        	// get all units
	        	HashMap<String, String> unitNamesByID = Unit.getUnitNamesByID();
	        	// get user roles
	           	HashSet<String> userRoles = new HashSet<String>(Role.getAssignedRoles(orgUserDN));
	           	// check if we have a valid principle assignment
	           	boolean validPrincipleAssignment = false;
	           	if (principleAssignment != null)
	           	{
	           		validPrincipleAssignment = validTeamAssignment(principleAssignment, unitNamesByID, userRoles);
	           	}
	           	// continue if principle is valid or we have just one assignment
	           	if (validPrincipleAssignment || (exportAssignments.size() == 1))
	           	{
	           		// compose list of assignments for import based on valid export assignments
	           		ArrayList<CordysObject> importAssignments = new ArrayList<CordysObject>();
	           		try
	           		{
		           		for (TeamAssignment exportAssignment : exportAssignments)
		           		{
		           			if (validTeamAssignment(exportAssignment, unitNamesByID, userRoles))
		           			{
		           				TeamAssignment importAssignment = new TeamAssignment();
		           				importAssignment.setUnitID(exportAssignment.getUnitID());
		           				importAssignment.setRoleDN(exportAssignment.getRoleDN());
		           				importAssignment.setUserDN(orgUserDN);
		           				importAssignment.setIsPrincipalUnit(exportAssignment.getIsPrincipalUnit());
		           				importAssignment.setEffectiveDate(exportAssignment.getEffectiveDate());
		           				importAssignment.setFinishDate(exportAssignment.getFinishDate());
		           				importAssignments.add(importAssignment);
		           			}
		           		}
		           		if (importAssignments.size() > 0)
		           		{
		           			// fire AddAssignmentsWithForcePrincipal
		           			TeamAssignment.addAssignments(orgUserDN, importAssignments);
		           		}
	           		}
	           		finally
	           		{
		           		for (CordysObject importAssignment : importAssignments)
		           		{
		           			importAssignment.cleanup();
		           		}
	           		}
	           	}
	        }
		}
	}
	
	/**
	 * Check if the potential assignment is valid : unit should be deployed and role should be in user roles
	 * 
	 * @param assignment
	 * @param allUnits
	 * @param userRoles
	 * @return
	 */
	private static boolean validTeamAssignment(TeamAssignment assignment, HashMap<String, String> allUnits, HashSet<String> userRoles)
	{
       	boolean validAssignment = false;
       	if (assignment != null)
       	{
       		String unitID = assignment.getUnitID();
       		validAssignment = allUnits.containsKey(unitID);
       		if (validAssignment)
       		{
       			String roleDN = assignment.getRoleDN();
       			validAssignment = userRoles.contains(roleDN);
       		}
       	}	
       	return validAssignment;
	}
	
	/**
	 * Substitute variables in the given xml
	 * 
	 * @param xmlNode
	 * @param properties
	 * @return
	 */
    private static int substituteVariables(int xmlNode, HashMap<String, String> properties)
    { 
    	// write to a string first, to which we will apply search and replace
    	String xmlString = Node.writeToString(xmlNode, false);
    	
    	// compose list of keys into regexpr from properties (equals the variable names)
    	StringBuilder keyList = new StringBuilder( "\\$(" );
    	for (String key : properties.keySet()) 
    	{
    		keyList.append(key); 
    		keyList.append("|"); 
    	}
    	keyList.append("[^\\s\\S])");
    	
    	// compile and match
    	java.util.regex.Pattern pattern = Pattern.compile(keyList.toString());
    	java.util.regex.Matcher matcher = pattern.matcher(xmlString);
    	StringBuffer result = new StringBuffer();
    	while (matcher.find())
    	{ 
    		// for each match, replace
    		String variable = matcher.group(1);
    		matcher.appendReplacement(result, (String)properties.get(variable)); 
    	}
    	matcher.appendTail(result);
    	
    	// load back into NOM
    	int resultNode = 0;
    	Document xmlDoc = BSF.getXMLDocument();	
		try 
		{
			resultNode = xmlDoc.parseString(result.toString());
		} 
		catch (Exception e) 
		{
			throw new UserAdminException("Internal error while substituting variables in export file", e);
		}
    	return resultNode; 
    }
    
    public static void removeExportUpload(String xmlStoreKey, String lastModified, String level)
    {
    	String original = xmlStoreKey;
    	String name = xmlStoreKey.substring(xmlStoreKey.lastIndexOf("/")+1);
    	XMLStore.deleteXMLObject(xmlStoreKey, lastModified, level, original, name);
    }
}
